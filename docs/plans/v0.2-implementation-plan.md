# VaultClip v0.2 Implementation Plan

**Status**: Draft
**Created**: 2025-12-25
**Target Version**: v0.2
**Focus**: Address critical P1 security gaps from v0.1

---

## Executive Summary

v0.1 successfully delivered core encryption functionality (AES-256-GCM, Keychain integration, App Sandbox). However, security analysis revealed 4 high-priority (P1) gaps that must be addressed before production use:

1. **vaultclip-g4x**: Missing screen recording protection
2. **vaultclip-0m6**: Decrypted text exposed in memory for UI preview
3. **vaultclip-zbt**: No mlock for swap prevention
4. **vaultclip-13n**: No Touch ID/biometric authentication

v0.2 will address these P1 issues plus add persistent storage to make the app practical for daily use.

---

## Goals

### Security Goals (Priority 1)

1. **Screen Capture Protection**: Prevent screen recording/accessibility APIs from capturing clipboard content
2. **Memory Protection Enhancement**: Implement mlock() to prevent sensitive data from hitting swap
3. **Minimal Memory Exposure**: Reduce lifetime of decrypted data in UI layer
4. **Authentication**: Require Touch ID/Face ID to access clipboard history

### Functionality Goals (Priority 2)

5. **Persistent Storage**: Encrypted SQLite database for clipboard history
6. **Per-Item Keys**: Enhanced security model with per-item encryption keys

---

## Issue Tracking

All tasks will be tracked as beads issues:

```bash
# Create v0.2 epic
bd create "v0.2: Security Enhancements" -t epic -p 1

# Create subtasks under epic (use --parent flag)
bd create "Implement screen recording protection" --parent vaultclip-xxx -t task -p 1
bd create "Add mlock() for sensitive memory pages" --parent vaultclip-xxx -t task -p 1
# etc.
```

---

## Implementation Plan

### Phase 1: Screen Recording Protection (vaultclip-g4x)

**Goal**: Prevent screen recording and accessibility APIs from capturing clipboard content

**Implementation**:

```swift
// MARK: - Screen Protection

extension NSWindow {
    func enableScreenProtection() {
        // Prevent screen recording/screenshots
        self.sharingType = .none

        // Mark window as private
        if #available(macOS 13.0, *) {
            self.collectionBehavior.insert(.auxiliary)
        }
    }
}

class ProtectedTextView: NSTextView {
    override func accessibilityValue() -> Any? {
        // Return generic label, not actual content
        return "Clipboard item (content hidden for security)"
    }

    override func accessibilityLabel() -> String? {
        return "Clipboard history item"
    }

    // Disable accessibility element entirely for content views
    override func isAccessibilityElement() -> Bool {
        return false
    }
}
```

**Testing**:
1. Enable screen recording (QuickTime, OBS)
2. Open VaultClip history
3. Verify window appears black/blank in recording
4. Test with VoiceOver disabled for content
5. Verify accessibility labels don't expose content

**Acceptance Criteria**:
- [ ] Window.sharingType = .none implemented
- [ ] Screen recordings show black/blank window
- [ ] Accessibility API returns generic labels only
- [ ] Tests pass: `testScreenRecordingProtection()`
- [ ] Documentation updated in security-implementation-status.md

**Estimated Effort**: 4-6 hours

---

### Phase 2: Memory Protection with mlock() (vaultclip-zbt)

**Goal**: Prevent sensitive data from being written to swap file

**Implementation**:

```swift
// MARK: - Enhanced Memory Protection

class SecureMemory {
    static func lockMemory<T>(_ data: UnsafeMutablePointer<T>, count: Int) throws {
        let size = MemoryLayout<T>.stride * count
        let result = mlock(data, size)

        guard result == 0 else {
            throw MemoryError.mlockFailed(errno: errno)
        }
    }

    static func unlockMemory<T>(_ data: UnsafeMutablePointer<T>, count: Int) throws {
        let size = MemoryLayout<T>.stride * count
        let result = munlock(data, size)

        guard result == 0 else {
            throw MemoryError.munlockFailed(errno: errno)
        }
    }
}

// Usage in ClipboardEncryption
class ClipboardEncryption {
    func decrypt(_ item: EncryptedClipboardItem) throws -> String {
        let key = try KeychainManager.getMasterKey()
        let nonce = try AES.GCM.Nonce(data: item.nonce)
        let sealedBox = try AES.GCM.SealedBox(nonce: nonce, ciphertext: item.ciphertext, tag: item.tag)

        let decryptedData = try AES.GCM.open(sealedBox, using: key)

        // Lock memory to prevent swapping
        var mutableData = decryptedData
        try mutableData.withUnsafeMutableBytes { ptr in
            guard let baseAddress = ptr.baseAddress else { return }
            try SecureMemory.lockMemory(baseAddress, count: ptr.count)
        }

        defer {
            // Zero and unlock memory
            mutableData.withUnsafeMutableBytes { ptr in
                guard let baseAddress = ptr.baseAddress else { return }
                memset_s(baseAddress, ptr.count, 0, ptr.count)
                try? SecureMemory.unlockMemory(baseAddress, count: ptr.count)
            }
        }

        guard let plaintext = String(data: mutableData, encoding: .utf8) else {
            throw EncryptionError.corruptedData
        }

        return plaintext
    }
}
```

**Considerations**:
- macOS limits on mlocked memory (check with `sysctl vm.max_map_count`)
- Performance impact (minimal for small clipboard items)
- Error handling if mlock fails (continue with warning)

**Testing**:
1. Decrypt clipboard item
2. Monitor with `vmmap` to verify memory is not pageable
3. Force memory pressure and verify data not swapped
4. Test with large clipboard items (10KB+)
5. Verify cleanup with munlock

**Acceptance Criteria**:
- [ ] mlock() called for all decrypted data
- [ ] munlock() called in defer block
- [ ] Error handling if mlock fails (warning, not fatal)
- [ ] Tests pass: `testMemoryLocking()`
- [ ] Performance impact < 5ms per decrypt
- [ ] Documentation updated

**Estimated Effort**: 6-8 hours

---

### Phase 3: Reduce Memory Exposure (vaultclip-0m6)

**Goal**: Minimize lifetime of decrypted data in UI layer

**Problem**: Currently, decrypted text is stored in Swift String for UI preview, which is immutable and can't be zeroed.

**Solution**: Use lazy decryption + immediate zeroing

```swift
// MARK: - Secure String Wrapper

struct SecurePreview {
    private let encrypted: EncryptedClipboardItem
    private let maxPreviewLength: Int = 100

    init(encrypted: EncryptedClipboardItem) {
        self.encrypted = encrypted
    }

    // Decrypt only when needed, immediately discard
    func generatePreview() -> String {
        guard let decrypted = try? ClipboardEncryption().decrypt(encrypted) else {
            return "[Decryption failed]"
        }

        // Create preview, discard full plaintext ASAP
        let preview = String(decrypted.prefix(maxPreviewLength))

        // Original string will be deallocated here
        // (Swift String still poses risk, but limited to 100 chars)
        return preview
    }
}

// MARK: - Updated UI

struct ClipboardItemRow: View {
    let item: EncryptedClipboardItem

    @State private var preview: String = ""
    @State private var showFullContent: Bool = false

    var body: some View {
        VStack(alignment: .leading) {
            if showFullContent {
                // Full decryption (only when user expands)
                FullContentView(item: item)
            } else {
                // Preview only (limited exposure)
                Text(preview)
                    .onAppear {
                        preview = SecurePreview(encrypted: item).generatePreview()
                    }
            }
        }
    }
}
```

**Alternative Approach**: Use Data + NSAttributedString for rendering (avoids String)

```swift
class SecureTextRenderer {
    // Render directly from Data without creating intermediate String
    static func render(_ data: Data, in textView: NSTextView) {
        defer {
            var mutableData = data
            zeroMemory(&mutableData)
        }

        // Convert Data -> NSAttributedString -> render
        // (NSAttributedString creation is still a concern, but better than String)
        guard let text = String(data: data, encoding: .utf8) else { return }

        textView.string = text
        // Immediately mark textView storage as sensitive (mlock if possible)
    }
}
```

**Testing**:
1. Monitor memory with `leaks` and `vmmap`
2. Measure lifetime of decrypted data (should be < 100ms)
3. Verify preview generation doesn't cache full plaintext
4. Test with Instruments (Allocations)

**Acceptance Criteria**:
- [ ] Preview generation decrypts on-demand only
- [ ] Full decryption only when user explicitly expands
- [ ] No cached decrypted Strings in UI state
- [ ] Memory profiling shows reduced exposure
- [ ] Tests pass: `testMinimalMemoryExposure()`
- [ ] Documentation updated

**Estimated Effort**: 8-10 hours

---

### Phase 4: Touch ID Authentication (vaultclip-13n)

**Goal**: Require biometric authentication to access clipboard history

**Implementation**:

```swift
import LocalAuthentication

// MARK: - Authentication Manager

class AuthenticationManager: ObservableObject {
    @Published var isAuthenticated: Bool = false

    private let context = LAContext()

    func authenticate() async throws {
        var error: NSError?

        // Check if biometric auth is available
        guard context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) else {
            // Fallback to password if no Touch ID/Face ID
            try await authenticateWithPassword()
            return
        }

        // Request Touch ID/Face ID
        let reason = "Authenticate to access clipboard history"

        do {
            let success = try await context.evaluatePolicy(
                .deviceOwnerAuthenticationWithBiometrics,
                localizedReason: reason
            )

            await MainActor.run {
                self.isAuthenticated = success
            }
        } catch {
            throw AuthError.biometricFailed(error)
        }
    }

    func authenticateWithPassword() async throws {
        // Fallback: system password prompt
        let success = try await context.evaluatePolicy(
            .deviceOwnerAuthentication,
            localizedReason: "Authenticate to access clipboard history"
        )

        await MainActor.run {
            self.isAuthenticated = success
        }
    }

    func lock() {
        isAuthenticated = false
        // Invalidate context to require fresh auth
        context.invalidate()
    }
}

// MARK: - Updated App

@main
struct VaultClipApp: App {
    @StateObject private var authManager = AuthenticationManager()

    var body: some Scene {
        MenuBarExtra("VaultClip", systemImage: "lock.shield") {
            if authManager.isAuthenticated {
                ContentView()
                    .environmentObject(authManager)
            } else {
                AuthenticationRequiredView()
                    .environmentObject(authManager)
            }
        }
    }
}
```

**Configuration**:

Add to `Info.plist`:
```xml
<key>NSFaceIDUsageDescription</key>
<string>VaultClip uses Face ID to protect your clipboard history.</string>
```

Add to entitlements:
```xml
<key>com.apple.security.device.audio-input</key>
<false/>
```

**Features**:
- Auto-lock after idle timeout (configurable, default 5 min)
- Lock when system sleeps
- Lock on demand (hotkey or menu item)
- Remember auth state for session (until lock)

**Testing**:
1. Test Touch ID success/failure
2. Test Face ID (if available)
3. Test fallback to password
4. Test auto-lock after timeout
5. Test lock on system sleep
6. Test with biometric disabled (password only)

**Acceptance Criteria**:
- [ ] Touch ID/Face ID required on first access
- [ ] Password fallback works
- [ ] Auto-lock after 5 min idle
- [ ] Lock on system sleep
- [ ] Manual lock via hotkey
- [ ] Tests pass: `testAuthenticationFlow()`
- [ ] Documentation updated

**Estimated Effort**: 10-12 hours

---

### Phase 5: Persistent Encrypted Storage (vaultclip-liy)

**Goal**: Store clipboard history on disk with encryption

**Implementation**:

```swift
import SQLite3

// MARK: - Encrypted Database

class EncryptedDatabase {
    private let dbPath: URL
    private var db: OpaquePointer?

    init() throws {
        // Store in Application Support
        let appSupport = FileManager.default.urls(
            for: .applicationSupportDirectory,
            in: .userDomainMask
        ).first!

        let vaultClipDir = appSupport.appendingPathComponent("VaultClip")
        try FileManager.default.createDirectory(at: vaultClipDir, withIntermediateDirectories: true)

        // Exclude from backups by default
        var vaultClipDirURL = vaultClipDir
        var resourceValues = URLResourceValues()
        resourceValues.isExcludedFromBackup = true
        try vaultClipDirURL.setResourceValues(resourceValues)

        dbPath = vaultClipDir.appendingPathComponent("clipboard.db")

        try openDatabase()
        try createSchema()
    }

    private func openDatabase() throws {
        guard sqlite3_open(dbPath.path, &db) == SQLITE_OK else {
            throw DatabaseError.openFailed
        }

        // Enable SQLite encryption (SQLCipher or custom encryption layer)
        // Note: SQLite doesn't have built-in encryption on macOS
        // Option 1: Use SQLCipher (third-party, requires audit)
        // Option 2: Encrypt each row with CryptoKit (what we'll do)
    }

    private func createSchema() throws {
        let sql = """
        CREATE TABLE IF NOT EXISTS clipboard_items (
            id TEXT PRIMARY KEY,
            timestamp INTEGER NOT NULL,
            ciphertext BLOB NOT NULL,
            nonce BLOB NOT NULL,
            tag BLOB NOT NULL,
            item_key_encrypted BLOB NOT NULL
        );
        CREATE INDEX IF NOT EXISTS idx_timestamp ON clipboard_items(timestamp DESC);
        """

        var error: UnsafeMutablePointer<CChar>?
        guard sqlite3_exec(db, sql, nil, nil, &error) == SQLITE_OK else {
            throw DatabaseError.createSchemaFailed
        }
    }

    func insert(_ item: EncryptedClipboardItem, itemKey: Data) throws {
        let sql = """
        INSERT INTO clipboard_items (id, timestamp, ciphertext, nonce, tag, item_key_encrypted)
        VALUES (?, ?, ?, ?, ?, ?);
        """

        var stmt: OpaquePointer?
        guard sqlite3_prepare_v2(db, sql, -1, &stmt, nil) == SQLITE_OK else {
            throw DatabaseError.insertFailed
        }

        defer { sqlite3_finalize(stmt) }

        // Bind parameters
        sqlite3_bind_text(stmt, 1, item.id.uuidString, -1, nil)
        sqlite3_bind_int64(stmt, 2, Int64(item.timestamp.timeIntervalSince1970))
        sqlite3_bind_blob(stmt, 3, (item.ciphertext as NSData).bytes, Int32(item.ciphertext.count), nil)
        sqlite3_bind_blob(stmt, 4, (item.nonce as NSData).bytes, Int32(item.nonce.count), nil)
        sqlite3_bind_blob(stmt, 5, (item.tag as NSData).bytes, Int32(item.tag.count), nil)
        sqlite3_bind_blob(stmt, 6, (itemKey as NSData).bytes, Int32(itemKey.count), nil)

        guard sqlite3_step(stmt) == SQLITE_DONE else {
            throw DatabaseError.insertFailed
        }
    }

    // Additional methods: fetch, delete, count, etc.
}
```

**Per-Item Key Architecture**:

```swift
// Master Key (in Keychain) -> Per-Item Key (encrypted, in DB) -> Clipboard Data

class EnhancedClipboardEncryption {
    func encrypt(_ plaintext: String) throws -> (EncryptedClipboardItem, Data) {
        // 1. Generate per-item key
        let itemKey = SymmetricKey(size: .bits256)

        // 2. Encrypt data with item key
        let nonce = AES.GCM.Nonce()
        let data = plaintext.data(using: .utf8)!
        let sealedBox = try AES.GCM.seal(data, using: itemKey, nonce: nonce)

        // 3. Encrypt item key with master key
        let masterKey = try KeychainManager.getMasterKey()
        let itemKeyData = itemKey.withUnsafeBytes { Data($0) }
        let itemKeyNonce = AES.GCM.Nonce()
        let encryptedItemKey = try AES.GCM.seal(itemKeyData, using: masterKey, nonce: itemKeyNonce)

        let item = EncryptedClipboardItem(
            id: UUID(),
            timestamp: Date(),
            ciphertext: sealedBox.ciphertext,
            nonce: Data(sealedBox.nonce),
            tag: sealedBox.tag
        )

        // Return both item and encrypted item key
        let encryptedKeyData = encryptedItemKey.combined!
        return (item, encryptedKeyData)
    }
}
```

**Benefits of Per-Item Keys**:
- Master key compromise doesn't expose all history immediately
- Can revoke individual items by deleting item key
- Supports future key rotation
- Limits blast radius of any single key compromise

**Testing**:
1. Create encrypted database
2. Insert 1000 items, verify all decrypt correctly
3. Test database corruption handling
4. Test backup exclusion (check resource flags)
5. Performance: insert/query/decrypt times
6. Test migration from in-memory to persistent

**Acceptance Criteria**:
- [ ] SQLite database created with proper schema
- [ ] Each item encrypted with unique per-item key
- [ ] Item keys encrypted with master key
- [ ] Database excluded from Time Machine backups
- [ ] Fetch queries use index (fast)
- [ ] Tests pass: `testPersistentStorage()`
- [ ] Migration script from v0.1 (if needed)
- [ ] Documentation updated

**Estimated Effort**: 16-20 hours

---

## Testing Strategy

### Unit Tests (New)

Create new test file: `VaultClipTests/SecurityEnhancementsTests.swift`

```swift
class SecurityEnhancementsTests: XCTestCase {
    func testScreenRecordingProtection() {
        // Verify window.sharingType = .none
    }

    func testMemoryLocking() {
        // Verify mlock() called and memory not pageable
    }

    func testMinimalMemoryExposure() {
        // Measure lifetime of decrypted data in UI
    }

    func testAuthenticationFlow() {
        // Test Touch ID/password flow
    }

    func testPersistentStorage() {
        // Test database CRUD operations
    }

    func testPerItemKeyEncryption() {
        // Verify per-item key architecture
    }
}
```

### Integration Tests

1. **End-to-End Encrypted Storage**:
   - Copy text → Encrypt → Store in DB → Fetch → Decrypt → Verify

2. **Authentication + Access**:
   - Lock app → Attempt access → Auth required → Unlock → Access granted

3. **Memory Protection Under Pressure**:
   - Decrypt 100 items → Force memory pressure → Verify no swap

### Security Verification

Run existing `scripts/verify-code-signing.sh` plus:

```bash
# Check for screen protection
grep -r "sharingType.*none" --include="*.swift" .

# Check for mlock usage
grep -r "mlock" --include="*.swift" .

# Check for authentication
grep -r "LocalAuthentication" --include="*.swift" .

# Check database encryption
grep -r "per-item key" --include="*.swift" .
```

---

## Documentation Updates

### Files to Update

1. **security-implementation-status.md**:
   - Update status for vaultclip-g4x, vaultclip-0m6, vaultclip-zbt, vaultclip-13n
   - Update Phase 1 and Phase 2 completion scores
   - Add notes on per-item keys

2. **IMPLEMENTATION_COMPLETE.md** → **history/v0.2-implementation-complete.md**:
   - Document all v0.2 changes
   - Update "Known Limitations" section
   - Update test coverage stats

3. **README.md**:
   - Update features list (add authentication, persistence)
   - Update security posture description
   - Update known limitations

4. **AGENTS.md**:
   - Add examples for screen protection code
   - Add examples for mlock usage
   - Add authentication patterns

---

## Migration Path

### From v0.1 to v0.2

**User Impact**: In-memory history will be lost on first v0.2 launch (no migration possible from v0.1).

**Process**:
1. Detect v0.1 usage (no database file)
2. Show one-time notice: "v0.2 introduces persistent storage. Previous clipboard history was not stored."
3. Create database and start fresh

**Future**: v0.2 → v0.3 will have proper database migration

---

## Success Criteria

### Must Have (Blocking Release)

- [ ] All P1 security issues closed (vaultclip-g4x, vaultclip-0m6, vaultclip-zbt, vaultclip-13n)
- [ ] Screen recording protection verified (manual test + automated)
- [ ] mlock() implemented and tested
- [ ] Touch ID authentication working
- [ ] Persistent storage functional
- [ ] All security tests pass
- [ ] Documentation updated
- [ ] Code signing verification passes

### Nice to Have (Can Defer)

- [ ] Per-item key rotation mechanism
- [ ] Configurable auth timeout
- [ ] Database optimization (vacuum, etc.)
- [ ] Import/export functionality

---

## Timeline Estimate

**Total Estimated Effort**: 44-56 hours

**Suggested Breakdown**:
- Week 1: Screen protection + mlock (10-14 hours)
- Week 2: Memory exposure + Touch ID (18-22 hours)
- Week 3: Persistent storage (16-20 hours)
- Week 4: Testing + documentation (catch-up)

**Target Completion**: 4 weeks from start

---

## Risks & Mitigations

### Risk 1: mlock() Fails on User Systems

**Impact**: Memory protection degraded
**Mitigation**: Log warning, continue without mlock (don't fail)
**Detection**: Monitor error logs, add telemetry (if user opts in)

### Risk 2: Touch ID Not Available

**Impact**: Can't use app if Touch ID required
**Mitigation**: Always provide password fallback
**Detection**: Test on systems without Touch ID

### Risk 3: Database Corruption

**Impact**: Loss of clipboard history
**Mitigation**:
- Regular integrity checks
- Automatic backups (encrypted)
- Recovery mode (rebuild from scratch)

### Risk 4: Performance Degradation with Large DB

**Impact**: Slow queries, UI lag
**Mitigation**:
- Limit total items (configurable, default 10,000)
- Use indexes on timestamp
- Lazy loading in UI (virtual scrolling)

---

## Future Work (v0.3)

After v0.2 is stable, consider:

1. **Data Classification**: Auto-detect passwords/API keys
2. **Differential Retention**: Auto-delete sensitive items
3. **App Exclusion List**: Never capture from password managers
4. **Key Rotation**: Rotate master key + re-encrypt all item keys
5. **Secure Sync**: Optional E2E encrypted sync (iCloud, own server)

---

## References

- [Security Requirements](./security-requirements.md) - Comprehensive security requirements
- [Security Implementation Status](./security-implementation-status.md) - Current status tracking
- [AGENTS.md](../../AGENTS.md) - Development guidelines and security principles
- [v0.1 Implementation](../../.worktrees/v0.1-prototype/history/IMPLEMENTATION_COMPLETE.md) - What was built in v0.1

---

**Questions? Issues?**

Track all v0.2 work in beads:
```bash
bd ready --json | jq 'select(.title | contains("v0.2"))'
```
